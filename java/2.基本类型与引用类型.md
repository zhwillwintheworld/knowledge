# 基本类型：既然Java一切皆对象，那又为何要保留int等基本类型？

## 1. 八种基本类型

1. 整型类型：byte（字节型）、short（短整型）、int（整型）、long（长整型）
2. 浮点类型：float（单精度）、double（双精度）
3. 字符类型：char
4. 布尔类型：boolean

Java不支持无符号类型。除此之外，不管32位JVM，还是64位JVM，这8种基本类型的长度（占用的字节个数）都是固定的，如下所示。对比C/C++，在32位编译器中，long类型的长度是4字节，而在64位编译器中，long类型的长度是8字节。

| 基本类型 | 字节大小 | 数值范围          | 默认值   |
| -------- | -------- | ----------------- | -------- |
| byte     | 1        | -128 ~ 127        | 0        |
| short    | 2        | -32768 ~ 32767    | 0        |
| int      | 4        | -2^31 ~ 2^31-1    | 0        |
| long     | 8        | -2^63 ~ 2^63-1    | 0L       |
| float    | 4        | -3.4e38~3.4e38    | 0.0f     |
| double   | 8        | -1.7e308~1.7e308  | 0.0      |
| char     | 2        | '\u0000'~'\uFFFF' | '\u0000' |
| boolean  | 1        | true or false     | false    |

### 1.1 对整数类型的说明

在byte、short、int、long这四个整型类型的数据范围中，负数比正数多一个。这是为什么呢？负数在计算机中是如何用二进制来表示的呢？计算机在第一位bit 上表示数值的正负 ，0代表正数 1 代表负数，0占一位，所以正数比负数少一位。

### 1.2 对浮点类型的说明

同样是4字节长度，为什么float表示的数据范围比int大？同理，为什么double表示的数据范围比long的大？因为浮点数用的是科学计数法，丢失了部分精度，却提高了数值范围。

### 1.3 对boolean类型的说明

boolean类型只有true和false两个值，理论上只需要1个二进制位就可以表示。我们知道，数据存储的位置是通过内存地址来标识的，内存地址一般以字节为单位，一个字节一个地址。单个二进制位很难存储和访问，考虑到字节对齐（第9节中会详讲），在JVM具体实现boolean类型时，大都采用1个字节来存储，用0表示false，用1表示true。尽管在存储空间上有些浪费，但操作起来更加简单。

### 1.4 对char类型的说明

````java
// char 是两个字节
// 例如
char x = '编';
String k = "编";
System.out.println(k.getBytes(StandardCharsets.UTF_8).length); // 输出3
````

java是用unicode来表示字符，"编"这个中文字符的unicode就是2个字节，String.getBytes(encoding)方法是获取指定编码的byte数组表示，通常gbk/gb2312是2个字节，utf-8是3个字节。如果不指定encoding则取系统默认的encoding. 即char与Character的编码不一样。

## 2. 基本类型转换

基本类型转换有两种：自动类型转换和强制类型转换。自动类型转化也叫做隐式类型转换，强制类型转换也叫做显式类型转化。一般来讲，从数据范围小的类型向数据范围大的类型转换，可以触发自动类型转换；从数据范围大的类型向数据范围小的类型转换，需要强制类型转换。不过，boolean类型数据不支持与任何类型的自动或强制类型转换。

## 3. 自动拆箱与装箱

Java一切皆对象，所以，对于基本类型，Java还提供了对应的包装类（Wrapper Class）。如下所示。其中，Number是整型和浮点型包装类的父类。

| 基本类型 | 包装类型  |
| -------- | --------- |
| byte     | Byte      |
| short    | Short     |
| int      | Integer   |
| long     | Long      |
| float    | Float     |
| double   | Double    |
| char     | Character |
| boolean  | Boolean   |

基本类型和包装类之间可以转换，这种转换可以显式执行，也可以隐式执行。Java提供了一些方法来实现这种显示的转换。以上八种基本类型和包装类在使用上类似，所以，我们只拿Integer类举例讲解，示例代码如下所示。

````java
int a = 5;
// 基本类型转换成包装类型
Integer b = Integer.valueOf(a);
Integer c = new Integer(a);

// 包装类型转换成基本类型
int d = b.intValue();
````

除了以上显式地调用方法来转换之外，Java还支持基本类型和包装类之间的隐式转换，专业的叫法为自动装箱（autoboxing）和自动拆箱（unboxing）。自动装箱是指自动将基本类型转换为包装类。自动拆箱是指自动将包装类转换为基本类型。示例代码如下所示。

````java
// 自动装箱
Integer a = 5;
// 自动拆箱
int b = a;
````

字面常量12是int基本类型的，当赋值给包装类Integer对象时，触发自动装箱操作，创建一个Integer类型的对象，并赋值给变量iobj。实际上，自动装箱只是一个语法糖，其底层相当于执行了Integer类的valueof()方法，如下所示。

````java
Integer a = 5;
// 底层实现为
Integer a = Integer.valueOf(5);
````
