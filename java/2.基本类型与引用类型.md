# 基本类型：既然Java一切皆对象，那又为何要保留int等基本类型？

## 1. 八种基本类型

1. 整型类型：byte（字节型）、short（短整型）、int（整型）、long（长整型）
2. 浮点类型：float（单精度）、double（双精度）
3. 字符类型：char
4. 布尔类型：boolean

Java不支持无符号类型。除此之外，不管32位JVM，还是64位JVM，这8种基本类型的长度（占用的字节个数）都是固定的，如下所示。对比C/C++，在32位编译器中，long类型的长度是4字节，而在64位编译器中，long类型的长度是8字节。

| 基本类型 | 字节大小 | 数值范围          | 默认值   |
| -------- | -------- | ----------------- | -------- |
| byte     | 1        | -128 ~ 127        | 0        |
| short    | 2        | -32768 ~ 32767    | 0        |
| int      | 4        | -2^31 ~ 2^31-1    | 0        |
| long     | 8        | -2^63 ~ 2^63-1    | 0L       |
| float    | 4        | -3.4e38~3.4e38    | 0.0f     |
| double   | 8        | -1.7e308~1.7e308  | 0.0      |
| char     | 2        | '\u0000'~'\uFFFF' | '\u0000' |
| boolean  | 1        | true or false     | false    |

### 1.1 对整数类型的说明

在byte、short、int、long这四个整型类型的数据范围中，负数比正数多一个。这是为什么呢？负数在计算机中是如何用二进制来表示的呢？计算机在第一位bit 上表示数值的正负 ，0代表正数 1 代表负数，0占一位，所以正数比负数少一位。

### 1.2 对浮点类型的说明

同样是4字节长度，为什么float表示的数据范围比int大？同理，为什么double表示的数据范围比long的大？因为浮点数用的是科学计数法，丢失了部分精度，却提高了数值范围。

### 1.3 对boolean类型的说明

boolean类型只有true和false两个值，理论上只需要1个二进制位就可以表示。我们知道，数据存储的位置是通过内存地址来标识的，内存地址一般以字节为单位，一个字节一个地址。单个二进制位很难存储和访问，考虑到字节对齐（第9节中会详讲），在JVM具体实现boolean类型时，大都采用1个字节来存储，用0表示false，用1表示true。尽管在存储空间上有些浪费，但操作起来更加简单。

### 1.4 对char类型的说明

````java
// char 是两个字节
// 例如
char x = '编';
String k = "编";
System.out.println(k.getBytes(StandardCharsets.UTF_8).length); // 输出3
````

java是用unicode来表示字符，"编"这个中文字符的unicode就是2个字节，String.getBytes(encoding)方法是获取指定编码的byte数组表示，通常gbk/gb2312是2个字节，utf-8是3个字节。如果不指定encoding则取系统默认的encoding. 即char与Character的编码不一样。

## 2. 基本类型转换

基本类型转换有两种：自动类型转换和强制类型转换。自动类型转化也叫做隐式类型转换，强制类型转换也叫做显式类型转化。一般来讲，从数据范围小的类型向数据范围大的类型转换，可以触发自动类型转换；从数据范围大的类型向数据范围小的类型转换，需要强制类型转换。不过，boolean类型数据不支持与任何类型的自动或强制类型转换。

## 3. 自动拆箱与装箱

Java一切皆对象，所以，对于基本类型，Java还提供了对应的包装类（Wrapper Class）。如下所示。其中，Number是整型和浮点型包装类的父类。

| 基本类型 | 包装类型  |
| -------- | --------- |
| byte     | Byte      |
| short    | Short     |
| int      | Integer   |
| long     | Long      |
| float    | Float     |
| double   | Double    |
| char     | Character |
| boolean  | Boolean   |

基本类型和包装类之间可以转换，这种转换可以显式执行，也可以隐式执行。Java提供了一些方法来实现这种显示的转换。以上八种基本类型和包装类在使用上类似，所以，我们只拿Integer类举例讲解，示例代码如下所示。

````java
int a = 5;
// 基本类型转换成包装类型
Integer b = Integer.valueOf(a);
Integer c = new Integer(a);

// 包装类型转换成基本类型
int d = b.intValue();
````

除了以上显式地调用方法来转换之外，Java还支持基本类型和包装类之间的隐式转换，专业的叫法为自动装箱（autoboxing）和自动拆箱（unboxing）。自动装箱是指自动将基本类型转换为包装类。自动拆箱是指自动将包装类转换为基本类型。示例代码如下所示。

````java
// 自动装箱
Integer a = 5;
// 自动拆箱
int b = a;
````

字面常量12是int基本类型的，当赋值给包装类Integer对象时，触发自动装箱操作，创建一个Integer类型的对象，并赋值给变量iobj。实际上，自动装箱只是一个语法糖，其底层相当于执行了Integer类的valueof()方法，如下所示。

````java
Integer a = 5;
// 底层实现为
Integer a = Integer.valueOf(5);
````

反过来，当把包装类对象iobj赋值给基本类型变量i时，触发自动拆箱操作，将iobj中的数据取出，再赋值给变量i。其底层相当于执行了Integer类的intValue()方法，如下所示。

````java
Integer b = a;
// 底层实现为
int b = a.intValue();
````

了解了自动装箱和自动拆箱原理之后，我们来看下，什么时候会触发自动装箱和自动拆箱。我总结了以下几种情况。

1. `将基本类型数据赋值给包装类变量（包括参数传递）时，触发自动装箱。`
2. `将包装类对象赋值给基本类型变量（包括参数传递）时，触发自动拆箱。`
3. `当包装类对象参与算术运算时，触发自动拆箱操作。`
4. `当包装类对象参与关系运算（<、>）时，触发自动拆箱操作。`
5. `当包装类对象参与关系运算（==），并且另一方是基本类型数据时，触发拆箱操作。`

自动装箱和自动拆箱给我们的开发带来了便利，但同时，不恰当的使用它们，也会导致性能问题。如下代码所示。

````java
public static void main(String[] args){
    Integer a = 0;
    for(int i = 0;i<1000;i++){
        a += 1;
    }
}
````

在上述代码中，count += 1等价于count = count + 1。因为Integer等包装类是不可变类（至于为什么设计成不可变类，我们在第8节中讲解），执行这条语句会先触发自动拆箱，执行加法操作，然后再触发自动装箱，生成新的Integer类对象，最后赋值给count变量。也就是说，执行上述代码，要执行10000次自动装箱和拆箱，并且生成10000个Integer对象，相对于如下代码实现方式，上述实现方式内存消耗大，执行速度慢。

## 4. 常量池技术

````java
public static void main(String[] args){
    Integer a = 5;
    Integer b = 5;
    Integer c = new Integer(5);
    System.out.printlf(a==b); // true
    System.out.printlf(a==c); // false
}
````

这是因为Integer等包装类使用了常量池技术。IntegerCache类中会缓存值为-128到127之间的Integer对象。当我们通过自动装箱，也就是调用valueOf()来创建Integer对象时，如果要创建的Integer对象的值在-128和127之间，会从IntegerCache中直接返回，否则才会真正调用new方法创建。Integer类的valueOf()的代码实现如下所示。

````java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
````

为什么IntegerCache只缓存-128到127之间的整型值呢？
在IntegerCache的代码实现中，当这个类被加载的时候，缓存的Integer对象会被集中一次性创建好。毕竟整型值太多了，我们不可能在IntegerCache类中预先创建好所有的整型值对象，这样既占用太多内存，也使得加载IntegerCache类的时间过长，更没有必要。所以，JVM只选择缓存对大部分应用来说常用的整型值，也就是一个字节范围内的整型值（-128~127）。

````java
Integer a = new Integer(5);
Integer b = 5;
Integer c = Integer.valueOf(5);
````

综上所述，在平时的开发中，对于下面这样三种创建整型对象的方式，我们优先使用后两种。这是因为，第一种创建方式并不会使用到IntegerCache，而后面两种创建方法可以利用IntegerCache缓存，返回共享的对象，以达到节省内存的目的。举一个极端一点的例子，假设应用程序需要创建1万个-128到127之间的Integer对象。使用第一种创建方式，我们需要分配1万个Integer对象的内存空间；使用后两种创建方式，我们最多只需要分配256个Integer对象的内存空间。

除了Integer类型之外，其他部分包装类也使用了常量池技术。其中，Long、Short、Byte利用常量池技术来缓存值在-128到127之间对象。Character利用常量池技术缓存值在0到127之间的对象（因为Character的值没有负数）。Float、Double表示浮点数，无法利用常量池技术。Boolean只有两个值，不需要使用常量池技术。

## 5. 基本类型与包装类

了解了基本类型和包装类，我们来对比一下两者的优缺点。

包装类是引用类型，对象的引用和对象本身是分开存储的，而对于基本类型数据，变量对应的内存块直接存储数据本身。所以，基本类型数据在读写效率方面，都要比包装类高效。除此之外，在64位JVM上在开启引用压缩的情况下，一个Integer对象占用16个字节的内存空间（关于这一点，我们在第9节详细讲解），而一个int类型数据只占用4字节的内存空间，前者对空间的占用是后者的4倍。

也就是说，不管是读写效率，还是存储效率，基本类型都比包装类高效。这就是Java保留基本类型的原因。尽管Java最初的设计理念是一切皆对象，这样可以统一对变量的处理逻辑，但为了性能做了妥协，毕竟基本类型数据在开发中使用太频繁了。

不过，包装类也有优势，它提供了更加丰富的方法，可以更加方便地实现复杂功能。

在项目开发中，首选基本类型，毕竟基本类型在性能方面更好。当然，也有一些特殊情况，比较适合使用包装类。比如映射数据库的Entity、映射接口请求的DTO，在数据库或请求中的字段值为null时，我们需要将其映射为Entity或DTO中的null值。还有，我们在初始化变量时，需要将其设置为没有业务意义的值，如果某个变量的默认值0是有业务意义的值，这个时候，我们需要找一个其他值（例如-1）来初始化变量。这种情况下，我们就推荐使用包装类，因为包装类变量的默认值是null，是没有业务意义的。
