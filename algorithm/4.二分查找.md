---
layout: 张华
title: 二分查找
date: 2022/4/15
html:
  embed_local_images: false
  embed_svg: true
  offline: false
  toc: true
print_background: false
---

# 二分查找

## 二分查找的常见知识点

1. 标准二分 （在有序的数组里，快速查找某个值是否存在）
2. 二分答案（最大化满足条件的值，最小化满足条件的值）
3. 求元素区间 （在有序的数组里，快速查找某个值的第一个下标以及最后一个下标）
4. 二分特殊处理 （稀疏数组，旋转数组）
5. 峰值二分 （在部分有序的数组里，查找峰值，--当前比右边小，那么右边一定有峰值）


## 二分查找对应的leetcode题

+ [704. 二分查找](https://leetcode-cn.com/problems/binary-search/) -- 1. 标准二分
+ [374. 猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/) -- 1. 标准二分
+ [744. 寻找比目标字母大的最小字母](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/) -- 1. 二分答案 求最小值
+ [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/submissions/)  -- 1. 二分答案 求最小值
+ [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/) -- 1. 求元素区间
+ [面试题 10.05. 稀疏数组搜索](https://leetcode-cn.com/problems/sparse-array-search-lcci/) -- 1.二分 （需要处理的是，如果碰到“”需要将指针右移）
+ [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/submissions/) --1. 二分，哪怕经过旋转，但是各部分在从左到右的方向上依然遵循守序
+ [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/) --1. 峰值二分，寻找数组最大值就能找到最小值
+ [852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/) --1.峰值二分
+ 


## 二分的经典代码

1 标准二分（无重复数据）

~~~~java
    public int binarySearch(int[] arr,int k){
        int lo = 0,hi = arr.length -1,mid;
        while(lo<=hi){
          mid = lo + ((hi - lo) >> 1);
          if(arr[mid]==k){
            return mid;
          }else if(arr[mid] > k){
            hi = mid -1;
          }else{
            lo = mid + 1;
          }
        }
        return -1;
    }
~~~~

2 二分答案 （查找有序数组里面，比目标值大的最小值）

~~~~java
    public int binarySearch(int[] arr, int k) {
        int lo = 0,hi=arr.length-1,mid;
        while(lo<=hi){
            mid = lo + ((hi -lo)>>1);
            if(arr[mid]<=k){
                lo = mid + 1;
            }else{
                hi = mid - 1;
            }
        }
        // 可能是没有
        if(lo==arr.length){
           return -1;
        }
        return arr[lo];
    }
~~~~

3 二分答案 （查找有序数组里面，比目标值小的最大值）

~~~~java
    public int binarySearch(int[] arr,int k){
        int lo = 0,hi = arr.length-1,mid;
        while(lo<=hi){
            mid = lo + ((hi - lo)>>1);
            if(arr[mid]<k){
                lo = mid + 1;
            }else{
                hi = mid - 1;
            }
        }
        // 可能是没有
        if(hi==-1){
            return -1;
        }
        return arr[hi];
    }
~~~~

4 求元素区间

~~~~java
    public int[] searchRange(int[] nums, int target) {
        if(nums.length==0){
            return new int[]{-1,-1};
        }
        int left = binarySearch(nums,target,true);
        int right = binarySearch(nums,target,false);
        return new int[]{left,right};
    }
    private int binarySearch(int[] nums,int target,boolean min){
        int lo = 0,hi = nums.length -1,mid;
        while(lo<=hi){
            mid = lo + ((hi-lo) >> 1);
            if(nums[mid]==target){
                if(min){
                    // 查找最小值
                    if(mid>0&&nums[mid-1]==target){
                        hi = mid -1;
                    }else{
                        return mid;
                    }
                }else{
                    //查找最大值
                    if(mid<nums.length-1&&nums[mid+1]==target){
                        lo = mid + 1;
                    }else{
                        return mid;
                    }
                }
            }else if(nums[mid]<target){
                lo = mid + 1;
            }else{
                hi = mid - 1;
            }
        }
        return -1;
    }
~~~~

5 二分特殊处理(旋转数组)

~~~~java
    public int search(int[] nums, int target) {
        int lo = 0,hi = nums.length-1,mid;
        while(lo<=hi){
            mid = lo + ((hi-lo)>>1);
            if(nums[mid]==target){
                return mid;
            }else{
                if(nums[lo]<=nums[mid]){
                    //lo - mid 是完全有序的
                    // target 在 lo - mid 中
                    if(target>=nums[lo]&&target<nums[mid]){
                        hi = mid -1;
                    }else{
                        // target 不在lo -mid 中
                        lo = mid + 1;
                    }
                }else{
                    // mid - hi 是完全有序的
                    // target 在 mid - hi 中
                    if(target>nums[mid]&&target<=nums[hi]){
                        lo = mid + 1;
                    }else{
                         // target 不在mid -hi 中
                        hi = mid -1;
                    }
                }
            }
        }
        return -1;
    }

~~~~

6 峰值二分 (求旋转数组的最小值)

~~~~java
    public int findMin(int[] nums) {
        if(nums.length==1){
            return nums[0];
        }
        int lo = 0,hi = nums.length-1,mid,right;
        while(lo<=hi){
            mid = lo + ((hi-lo)>>1);
            right = mid + 1==nums.length?0:mid + 1;
            // 找到峰值（最大值）,最小值就在最大值的右边
            if(nums[mid]>nums[right]){
                return nums[right];
            }else{
                // 如果左边的值比中间值小，那么峰值一定在中间值的右边
                if(nums[lo]<=nums[mid]){
                    lo = mid + 1;
                }else{
                    hi = mid -1;
                }
            }
            
        }
        return nums[lo];
    }
~~~~

7 峰值二分（162. 寻找峰值）
~~~~java
    public int findPeakElement(int[] nums) {
        if(nums.length==1){
            return 0;
        }
        int lo = 0,hi = nums.length-1,mid;
        while(lo<hi){
            mid = lo + ((hi-lo)>>1);
            if(nums[mid]<nums[mid+1]){
                lo = mid + 1;
            }else{
                hi = mid ;
            }
        }
        return lo;
    }
~~~~

8 求平方根

~~~~java
  public int mySqrt(int x) {
       int min = 1;
       int max = x;
       int mid ;
       while(min<=max){
           mid = min + ((max - min) >> 1);
           if(x/mid==mid){
               return mid;
           }else if(x/mid>mid){
               min = mid + 1;
           }else{
               max = mid -1 ;
           }
       }
       return min-1;

    }
~~~~