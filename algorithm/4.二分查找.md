---
layout: 张华
title: 二分查找
date: 2022/4/15
html:
  embed_local_images: false
  embed_svg: true
  offline: false
  toc: true
print_background: false
---

# 二分查找

## 二分查找的常见知识点

1. 在有序的数组里，快速查找某个值是否存在
2. 在有序的数组里，查询比目标值大的最小值
3. 在有序的数组里，查询比目标值小的最大值
4. 在部分有序的数组里，查找峰值，峰值二分 （当前比右边小，那么右边一定有峰值）
5. 二分答案

## 二分查找对应的leetcode题

+ [704. 二分查找](https://leetcode-cn.com/problems/binary-search/) -- 1. 标准二分
+ [374. 猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/) -- 1. 标准二分
+ [744. 寻找比目标字母大的最小字母](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/) -- 1. 比目标值大的最小值
+ [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/submissions/)  -- 1. 比目标值大的最小值 
+ [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/) -- 1.等于目标值的最左最右区间,见代码4
+ 


## 二分的经典代码

1 标准二分（无重复数据）

~~~~java
    public int binarySearch(int[] arr,int k){
        int low = 0,hi = arr.length -1,mid;
        while(low<=hi){
          mid = low + ((hi - low) >> 1);
          if(arr[mid]==k){
            return mid;
          }else if(arr[mid] > k){
            hi = mid -1;
          }else{
            low = mid + 1;
          }
        }
        return -1;
    }
~~~~

2 查找有序数组里面，比目标值大的最小值

~~~~java
    public char nextGreatestLetter(char[] letters, char target) {
        int low = 0,hi=letters.length-1,mid;
        while(low<=hi){
            mid = low + ((hi -low)>>1);
            if(letters[mid]<=target){
                low = mid + 1;
            }else{
                hi = mid - 1;
            }
        }
        return letters[low%letters.length];

    }
~~~~


4 查找有序数组里面，等于目标值的下标区间

~~~~java
    public int[] searchRange(int[] nums, int target) {
        if(nums.length==0){
            return new int[]{-1,-1};
        }
        int left = binarySearch(nums,target,true);
        int right = binarySearch(nums,target,false);
        return new int[]{left,right};
    }
    private int binarySearch(int[] nums,int target,boolean min){
        int lo = 0,hi = nums.length -1,mid;
        while(lo<=hi){
            mid = lo + ((hi-lo) >> 1);
            if(nums[mid]==target){
                if(min){
                    if(mid>0&&nums[mid-1]==target){
                        hi = mid -1;
                    }else{
                        return mid;
                    }
                }else{
                    if(mid<nums.length-1&&nums[mid+1]==target){
                        lo = mid + 1;
                    }else{
                        return mid;
                    }
                }
            }else if(nums[mid]<target){
                lo = mid + 1;
            }else{
                hi = mid - 1;
            }
        }
        return -1;
    }
~~~~